# modules/doctors/models.py
from sqlalchemy import Column, Integer, String, JSON, ForeignKey, DateTime, Boolean
from sqlalchemy.orm import relationship
from modules.core.db import Base
import datetime

class Doctor(Base):
    __tablename__ = "doctors"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), unique=True, nullable=False)
    specialization = Column(String, nullable=True)
    qualifications = Column(String, nullable=True)
    bio = Column(JSON, nullable=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)

    user = relationship("User", back_populates="doctor")
    slots = relationship("DoctorSlot", back_populates="doctor", cascade="all, delete-orphan")

class DoctorSlot(Base):
    __tablename__ = "doctor_slots"
    id = Column(Integer, primary_key=True, index=True)
    doctor_id = Column(Integer, ForeignKey("doctors.id", ondelete="CASCADE"), nullable=False)
    start_datetime = Column(DateTime, nullable=False)
    end_datetime = Column(DateTime, nullable=False)
    is_booked = Column(Boolean, default=False, nullable=False)

    doctor = relationship("Doctor", back_populates="slots")


# modules/doctors/schemas.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class DoctorCreate(BaseModel):
    specialization: Optional[str]
    qualifications: Optional[str]
    bio: Optional[str]

class SlotCreate(BaseModel):
    start_datetime: datetime
    end_datetime: datetime

class DoctorOut(BaseModel):
    id: int
    user_id: int
    specialization: Optional[str]
    qualifications: Optional[str]
    bio: Optional[str]
    class Config:
        orm_mode = True

class SlotOut(BaseModel):
    id: int
    doctor_id: int
    start_datetime: datetime
    end_datetime: datetime
    is_booked: bool
    
    model_config = {"from_attributes": True}

class SlotRangeCreate(BaseModel):
    start_datetime: datetime
    end_datetime: datetime


# modules/doctors/crud.py
from sqlalchemy.orm import Session
from modules.doctors.models import Doctor, DoctorSlot
from datetime import datetime, timedelta, timezone

def create_doctor_profile(db: Session, user_id: int, specialization: str | None = None, qualifications: str | None = None, bio: str | None = None):
    doc = Doctor(user_id=user_id, specialization=specialization, qualifications=qualifications, bio=bio)
    db.add(doc)
    db.commit()
    db.refresh(doc)
    return doc

def get_doctor_by_user_id(db: Session, user_id: int):
    return db.query(Doctor).filter(Doctor.user_id == user_id).first()

def create_slot(db: Session, doctor_id: int, start_datetime: datetime, end_datetime: datetime):
    # Convert incoming datetimes to UTC
    start_datetime_utc = start_datetime.astimezone(timezone.utc)
    end_datetime_utc = end_datetime.astimezone(timezone.utc)
    
    slot = DoctorSlot(
        doctor_id=doctor_id,
        start_datetime=start_datetime_utc,
        end_datetime=end_datetime_utc
    )
    db.add(slot)
    db.commit()
    db.refresh(slot)
    return slot

def create_slots_range(db: Session, doctor_id: int, start: datetime, end: datetime, slot_duration_minutes: int = 30):
    slots = []

    # Convert start and end to UTC
    current = start.astimezone(timezone.utc)
    end = end.astimezone(timezone.utc)

    while current < end:
        slot = DoctorSlot(
            doctor_id=doctor_id,
            start_datetime=current,
            end_datetime=current + timedelta(minutes=slot_duration_minutes),
            is_booked=False
        )
        db.add(slot)
        slots.append(slot)
        current += timedelta(minutes=slot_duration_minutes)
    db.commit()
    
    for slot in slots:
        db.refresh(slot)
    return slots

def get_available_slots(db: Session, doctor_id: int):
    now = datetime.utcnow()
    return db.query(DoctorSlot).filter(DoctorSlot.doctor_id == doctor_id, DoctorSlot.is_booked == False, DoctorSlot.start_datetime >= now).order_by(DoctorSlot.start_datetime).all()


# modules/doctors/routes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from modules.core.db import get_db
from modules.auth.security import get_current_user
from modules.users.models import User
from modules.doctors import crud, schemas

router = APIRouter(prefix="/doctors", tags=["doctors"])

@router.post("/me", response_model=schemas.DoctorOut)
def create_or_update_doc_profile(payload: schemas.DoctorCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if current_user.role != "doctor":
        raise HTTPException(status_code=403, detail="Only doctors can create a doctor profile")
    existing = crud.get_doctor_by_user_id(db, current_user.id)
    if existing:
        # simple update
        existing.specialization = payload.specialization or existing.specialization
        existing.qualifications = payload.qualifications or existing.qualifications
        existing.bio = payload.bio or existing.bio
        db.commit()
        db.refresh(existing)
        return existing
    new = crud.create_doctor_profile(db, current_user.id, payload.specialization, payload.qualifications, payload.bio)
    return new

@router.post("/me/slots", response_model=schemas.SlotOut)
def create_slot(slot: schemas.SlotCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if current_user.role != "doctor":
        raise HTTPException(status_code=403, detail="Only doctors")
    doctor = crud.get_doctor_by_user_id(db, current_user.id)
    if not doctor:
        raise HTTPException(status_code=404, detail="Doctor profile not found")
    new_slot = crud.create_slot(db, doctor.id, slot.start_datetime, slot.end_datetime)
    return new_slot

@router.get("/me/slots", response_model=list[schemas.SlotOut])
def list_my_available_slots(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if current_user.role != "doctor":
        raise HTTPException(status_code=403, detail="Only doctors")
    doctor = crud.get_doctor_by_user_id(db, current_user.id)
    if not doctor:
        raise HTTPException(status_code=404, detail="Doctor profile not found")
    return crud.get_available_slots(db, doctor.id)

@router.post("/me/slots-range", response_model=list[schemas.SlotOut])
def create_slots_range(payload: schemas.SlotRangeCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if current_user.role != "doctor":
        raise HTTPException(status_code=403, detail="Only doctors")
    doctor = crud.get_doctor_by_user_id(db, current_user.id)
    if not doctor:
        raise HTTPException(status_code=404, detail="Doctor profile not found")
    slots = crud.create_slots_range(db, doctor.id, payload.start_datetime, payload.end_datetime)
    return slots
